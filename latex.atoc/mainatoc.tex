\documentclass{article}
%% \documentclass[dvipdfmx,a4paper]{article}


%%% macros
%%\input{narrowermargin} %% lncs contents with narrower margins
%%% begin: papersize with narrower margins
%% \usepackage[papersize={50mm,50mm}]{geometry}
\input{mymarginnarrower}
%% \input{myarith}
%%% end: papersize
\usepackage{amsmath,amssymb}
\usepackage{amsthm} %%proof environment
%%% auto labeling
\usepackage{mathtools}
\mathtoolsset{showonlyrefs=true}
%%% end: auto labeling
\usepackage{enumerate}
\usepackage{booktabs}
\usepackage{graphicx}
\graphicspath{
  {latex/fig/}
  {fig/}
}%%画像のパス．末尾は'/'で終わること
%%%% algo
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\input{myalgo2e}
%%%
%% \usepackage{natbib}
%\setcitestyle{numbers,super}
%%%
\usepackage{tikz}
\usetikzlibrary{calc}
%\usetikzlibrary{intersections,calc,arrows.meta}

%%% macro private
\input{config}
\input{macros}
\input{notation}
%\input{latex/macros2}

%%% 
\title{
Converting Suffix Array into Compacted Directed Acyclic Word Graph
%% Technical Notes: Generating Text Indexing Arrays Based on the Compacted Directed Acyclic Word Graphs
}
\author{Hiroki Arimura\\
Hokkaido University
}
\date{\today}
%%%% end macros

\begin{document}
\maketitle

\begin{abstract}
%% This paper studies the relationships between a graph-based index of size $e$, called the compact directed acyclic word graph (CDAWG), and various text index arrays whose sizes are upper bounded by $e$: the suffix array (SA), Burrows-Wheeler transform (BWT), longest common prefix array (LCP), LZ-parse (LZ77), and Lex-parse (LEX). As a main result, we show that for each index array listed above, there exists a grammar of size $O(e)$ that generates it. Furthermore, the grammar can be computed from the CDAWG in $O(e)$ time and space. As corollaries, we give algorithms to directly compute the above index arrays from the CDAWG in input and output linear time and space.
\end{abstract}

%%%%% body %%%%%%%%%%%%%%%%%%%%%%%%

%%%% 
\section{Introduction}
\label{sec:intro}

\subsection{Background}
%%% 
The goal of the problem is to transform the suffix array of a string $S$ (Manber and Myers~\cite{manber:myers1993suffixarrays}) with length $n$ into an equivalent DAG-based string index structure, called the \textit{CDAWG} (\textit{Compacted Directed Acyclic Word Graph}), of the string (Blumer, Blumer, Haussler, McConnell, and Ehrenfeucht~\cite{blumer1987complete}). Here, the CDAWG of a string $S$ is the path-compacted smallest automaton $C$ for accepting the set of all suffixes of $S$.
Although both structures, given a string $S$ of length $n$, compactly
%%%%
\myfootnote{
  In the recent literature on succinct data structures for indexing a string, a data structure that stores a string of length $n$ in $O(n \log\sigma)$ bits of space is commonly called compact, where $\sigma$ is the size of alphabet. On the contrary, throughout this article, we use the term \textit{compact} in more classical sense, meaning that an indexing data structure is said to be \textit{compact} if it represents all of $O(n^2)$ factors of a string $S$ of length $n$ in linear or less words in $n$. 
}
%%%%
store all of $O(n^2)$ factors in linear or less words of space supporting a similar set of operations efficiently, the latter compresses the former by reducing its space from $O(n)$ to $O(e_{\max})$, where $e_{\max}$ is a parameter that measures the compressibility of a string. The parameter $e_{\max} = e_R + e_L$ is defined as the sum of the the numbers $e_R$ and $e_L$ of all right- and left-extensions of the maximal repeats of the string.

\subsection{Problem}
%%% 
In this article, we study the following question. 

\begin{trivlist}{\item[] \noindent \textbf{Question.}
How to build the CDAWG $G$ of a string $S$ from the suffix array with auxiliary arrays and structures of total length $O(n)$ in output-sensitive time and space, that is, in the time and working space proportional to the output size $e_{\max}$ of $G$?
}\end{trivlist}

As read-only inputs, we assume all or a subset of the following structures are given to an algorithm, which are preprocessed from $S$ beforehand, and given to an algorithm:
\begin{itemize}
\item the suffix array $SA$,
\item the inverse suffix array $ISA$,
\item the longest common prefix array $LCP$.
\end{itemize}

We assume the following data structures on a given array n$A$ to augment one of the above arrays:  
\begin{itemize}
\item the range-minima query (RMQ) structure on $A = LCP$: Given a SA-range $[i..j]$, returns the minimum of the values $\{A[i], A[i+1], \dots, A[j]\}$ within $i..j$; 
  
\item the range-distinct query (RDQ) structure on $A = BWT$: returns the set of mutually distinct elements of $\{A[i], A[i+1], \dots, A[j]\}$ within $i..j$, 
\end{itemize}
where $A[1..n]$ is an arbitrary integer array of length $n$ and $i..j$ is any sub-range with $1\le i\le j\le n$. 

We assume that the LCP and the BWT are equipped with the RMQ and RDQ structures, respectively. 
All of the above structures occupy $O(n)$ words of space, and can be constructed in $O(n)$ time from a string $S$ over an integer alphabet in preprocessing (for details, see the textbook or survey article by Navarro~\cite{navarro2016cds:book,navarro2021indexing:ii}).

\subsection{Results}
%%% 
Throughout, we assume an integer alphabet $\Sigma$.
We also assume as inputs the combination of $SA, ISA$, $LCP$ with the RMQ structure, and $BWT$ with the RDQ structure. 
Then, we show the following theorem.

\begin{theorem}
  The CDAWG $G$ of a string $S$ with length $n$ over $\Sigma$ can be constructed in $O(e_{\max})$ time and $O(\max\{e_{\max}, \sigma^2\log n\})$ working space in addtion to the read-only input size $O(n)$, based on a read-only inputs consisting of the afoementioned structures for $S$.  
Here, $e_{\max} = e_{\max}(S) = e_R(S) + e_L(S)$ is the sum of the right- and left-extension parameters of the string, which can be logarithmically smaller than the string length $n$ for highly-repetitive strings.\end{theorem}

From the above theorem, the proposed algorithm has smaller asymptotic time complexity of $O(e_{\max})$ than the $\Theta(n)$-time complexity of the basic algorithm via suffix tree construction, retaining a similar space complexity of $O(e_{\max}\,\idrm{polylog}(n))$ to the repetition-aware algorithm by Nishimoto and Tabei~\cite{nishimoto:cpm2021enum}.
It is also time efficient than approaches of using as a base algorithm the traversal algorithm by Abouelhoda \textit{et al.}~\cite{abouelhoda2004replacing} or one by Narisawa \textit{et al.}~\cite{narisawa2007efficient}. 


%%Fibonacci and Thue-Morse words.
%% Since it is known that both of $e_{\max}(S)$ and $r$ are $\Theta(\log n)$ for any Thue-Morse words of length $n$,

%%%%
\section{Preliminaries}
\label{sec:prelim}

\subsection{Basic definitions}
We begin with basic definitions and notation following~\cite{charalampopoulos2018extended,barton2014linear,ilie2011minimum,belazzougui2015space:unusual}.
For any integers $i\le j$, we denote by $i..j$ or $[i..j]$ the \textit{discrete interval} $\set{i, i+1, \dots, j}$. For a set $A$, we denote by $|A|$ the \textit{cardinality} of $A$, by $A^*$ and $A^+$ the \textit{sets of all finite sequences} of length $\ge 0$ and length $\ge 1$ over $A$, respectively.
%%% 
As a model of computation, we assume the \textit{unit-cost RAM model}~\cite{cormen2009introduction} with machine word size $w = \floor{\log n}$ equipped with the standard Boolean and arithmetic operations over integers, where $n$ is an input size.

%%%% Strings
\subsection{Strings, factors, and maximal repeats}

Throughout, we assume an integer alphabet $\Sigma = \set{1, \dots, \sigma}$ with size $\sigma \ge 2$. 
For a string $s = a_1\dots a_n \in \Sigma^*$ of length $n = |s|$ over $\Sigma$ and any integers $1\le i\le j\le n$, $s[i..j] = a_i a_{i+1}\dots a_j$ denotes the \textit{factor}, or a \textit{substring}, of $s$ that starts and ends at positions $i$ and $j$, respectively. The \textit{empty word} of length~$0$ is denoted by~$\eps$. For any $i$, factors $s[1..i]$ and $s[i..n]$ are called a \textit{prefix} and a \textit{suffix} of $s$. The \textit{concatenation} of strings $x$ and $y$ is denoted by $x\cdot y$ or $xy$, and they are said to be \textit{proper} if $i < n$ and $i > 1$, respectively. 
In what follows, we denote by $\Sub(S)$ and $\Suf(S)$ the \textit{sets of all factors} and \textit{all suffixes} of a string $S$, respectively. 

%% \subsection{Maximal repeats}
%% %%% 
A \textit{maximal repeat} of a string $S$ is a maximal factor $u$ of $S$ that cannot be extended rightward or leftward without losing its occurrences in $S$. A \textit{right-extension} (resp.~a \textit{left-extension}) of a maximal repeat $u$ of $S$ is a string $ua$ (resp.~$au$) that is also a factor of $S$, namely, $ua \in \Sub(S)$ (resp.~$ua \in \Sub(S)$), with some character $b \in \Sigma$.
The parameters $\mu = \mu(S)$, $e_R = e_R(S)$, and $e_L = e_L(S)$ of a string $S$ are defined to be the numbers of the maximal repeats, their right-extensions, and left-extensions of $S$, respectively. It is known that $\mu(S) \le \max\{e_R(S), e_L(S)\} \le 2n - 2$ for any string $S$ of length $n$ (Blumer \textit{et al.}~\cite{blumer1987complete}).
Belazzougui \textit{et al.}~\cite{belazzougui:nunial:gagie:prezza:raffinot2015composite} showed that the parameter $e_R(S)$ upperbounds popular compression parameters $z(S)$ and $r(S)$ from above, that is, $\max\{z(S), r(S)\} \le e_R$, where $z(S)$ and $r(S)$ are the numbers of \textit{phrases of the Lemple-Ziv parse} of $S$ and \textit{equi-letter runs of the Burrows-Wheeler transform} of a string~$S$. 

For the lack of space, we assume that the reader has the basic knowledge of the suffix tree and the CDAWG of a string $S$, as well as that of the suffix arrays (SA) and its inverse array (ISA), longest common prefix array (LCP), and the Burrows-Wheeler transform (BWT) of $S$. Briefly, 

%%%% 
\section{Solution}
\label{sec:solution}

In this section, we present an $O(e_{\max})$-expected time solution over an integer alphabet.

\subsection{Outline of the algorithm}
%%%
Let $\Sigma$ be an alphabet with $|\Sigma(S)| \ge 2$ characters. 

\mysubsubsection{Top-level structure}
%%%% 
In \cref{algo:main}, we show the top-level structure of our algorithm for transforming the suffix array of a string $S$ with auxiliary structures with length $n$ into the CDAWG $G$ of the string. In preprocessing, an index structure $\sig I = (\SA, \ISA, \LCP, S)$ is constructed from an input string~$S$ of length $n$ over $\Sigma$ in linear time using appropriate construction algorithms~\cite{navarro2016cds:book,navarro2021indexing:ii}.
In runtime, the CDAWG $G$ of $S$ is constructed on $\sig I$. 

%%%%
{
% \setlength{\interspacetitleruled}{0pt}%
\setlength{\algotitleheightrule}{0pt}%
\begin{algorithm}[h]
  \caption{Transforming $SA$ and $S$ into its CDAWG $G$.
    %% Transforming the suffix array of a string $S$ with auxiliary structures with length $n$ into the CDAWG $G$ of the string.
  }\label{algo:main}
\KwPreproc{Construct an index $\sig I = (\SA, \ISA, \LCP, S)$ from $SA$ and $S$.}  
\KwRuntime{Perform the following steps}
\Begin{
    Compute $\LPT[+](S) \gets \Rec(\pair{1..n, 0}, \sig I)$\;
    $G \gets$ the DAG obtained from $\LPT[+](S)$ by merging non-maximal nodes to maximal nodes\;
    Return the CDAWG $G$\; 
}
\end{algorithm}
}
%%%%%%%%%

In an application senario in a human genome repository, the structure $\sig I$ will be constructed once, reside on memory using $O(n)$ space, and be used many times for the generation of the CDAWG in $O(e_{\max})$ time and working space per execution, and other purposes, such as the standard string search.

To describe our algorithm, we will introduce a virtual rooted tree $\LPT[+](S)$, called the \textit{extended longest common prefix tree} of $S$ in the following subsections.
Intuitively, $\LPT[+](S)$ is an edge-compacted rooted tree $T = (\sig V_+, \sig E_+, \eps)$ obtained from the CDAWG $G = (\sig V = \MR(S), \sig E, \eps)$ of $S$, by cutting all non-primary arcs in $\sig E$ to separate them from maximal repeats, and replacing the heads of arcs with fresh dammy nodes. Its node set is the union $\MR(S)\cup \Delta(S)$ of the set $\MR(S)$ of all maximal repeats and the set $\Delta(S)$ of dammy nodes representing non-maximal repeats. $\LPT[+](S)$ can be stored in $O(e_R)$ words, and can be easily converted into the CDAWG $G$ in $O(e_R)$ time. 

\mysubsubsection{Recursive subprocedure}
%%%% 
In \cref{algo:rec}, we show the recursive subprocedure $\Rec$ that given the triple $\pair{1..n, 0}$ for the empty string $\eps$, recursively constructs the extended LPT tree $T = \LPT[+](S)$ of a string $S$ on an index structure~$\sig I$. It systematically enumerates the set $\MR(S)$ of all maximal repeats, a class of special factors of $S$, in top-down manner from shorter to longer. In the procedure $\Rec$, each maximal repeat $u$ is encoded as the triple $\pair{i, j, \ell} = \pair{i..j, \ell}$, called the rich-representation, or simply the \textit{triple} of $u$, where $i..j$ is its SA-range of $u$ in $SA$ and $\ell = |u|$ is its length.

The procedure $\Rec$ works as follows: 
%%where maximal repeats are a class of special factors of $S$. 
\begin{itemize}
\item It starts with the triple $\op{rep}(\eps)$ of the shortest maximal repeat, i.e., $\eps$, and the initial DAG $G = (\set{\eps}, \emptyset{}, \eps)$. 
  
\item At each iteration with the triple $\op{rep}(u) = \pair{i..j, \ell}$ of a maximal repeat $u \in \MR(S)$, it generates the triples of a maximal repeat $v_b$ in $\MR(S)\setminus{\eps}$ as a children of $u$ for possible character $b\in\Sigma$, and then, recursively call itself with $v$ and $G$ as arguments. The generation of children of the parent $u$ will be described in the later subsections. 
%% maximally expands rightwards the right-extension $ua$ of $u$ with each distinct character $b \in \Sigma$ that appears in $S$ to the right of an occurrence of $u$. 
\end{itemize}

To show the correctness and time complexity, we will show that $\Rec$ simulate a top-down traversal of $\LPT[+](S)$ by visiting all of $O(\mu(S))$ members of $\MR(S)$, following $O(e_R(S))$ arcs, and backtracking when it eventually reaches a non-member of $\MR(S)$.
In the following subsections, we will explain more details of the above procedure. 

%% The tree $\LPT[+](S)$ is rooted at the empty string $\eps$ as the shortest maximal repeat, and whose edge set $\sig E_+ = \sig E \cup \sig F$ consists of the set $\sig E$ of all edges connecting maximal repeats, and additionally contains a set $\sig F$ of edges that are associated with the failure of traversal. 

%%%%%%%%%%%%%5
\begin{algorithm}[t]
  \caption{
    A subprocedure $\Rec$ for constructing the extended LPT-tree $\LPT[+](S)$ of the string $S$ on an index $\sig I = (\SA, \ISA, \LCP, S)$.
    %% for enumerating the set $\MR(S)$ of all maximal reepeats of the string $S$ prefixed by the word $u := \getfactor(i..j, \ell)$. 
}\label{algo:rec}
%%%\medskip
  \KwInput{
    A triple $\pi = \pair{i..j, \ell} \in \RR$ and a rooted tree $T = (\sig V_+(T), \sig E_+(T), \eps)$. 
  }
  \KwOutput{
    A subgraph $T = (\sig V_+(T), \sig E_+(T), \eps)$ of $\LPT[+](S)$. 
  }
  \textbf{procedure} \Rec$(\pi, T)$\;
  \Begin{
      \Comment{Pre-condition: $\pi = \pair{i..j, \ell}$ represents a maximal repeat, say $u$, in $\MR(S)$.}
      %% $Children \gets \emptyset$\; 
      $Children \gets \GenChildren(i..j, \ell, \op{undef})$\Comment*{See \cref{lem:genchildren}}
      \label{line:recmr:for:begin}
      \For {each child $(c, \tau_c = \pair{i_c..j_c, \ell_c})$ in $Children$}{
             \Comment{Post-condition:
               $c \in \RSigma(u)$ is a branching character and 
               $\tau_c$ represents
               an $c$-child $\rext{uc} \in \MR(S)$ of $u$. 
             }
             $\sig V(T) \gets \sig V(T) \cup\set{ \tau_c }$
             \Comment*{Adding a node to $\sig V(T) = \MR(S)\cup\Delta(S)$}
             $\sig E(T) \gets \sig E(T) \cup\set{ (\pi, \tau_c) }$
             \Comment*{Adding an arc to $\sig E(T) = \sig E\cup\sig F$}
             \uIf (\comblk{See \cref{lem:leftmaximal:character}}) {$\isLeftBranching(i_c..j_c, \ell_c)$}{
               $\Rec(\tau_c, T)$
               \Comment*{$\tau_c$ and $(\pi, \tau_c)$ belong to $\sig M$ and $\sig E$, resp.}
               \label{line:recmr:for:end}
             } %% If
             \Else{
               $\rhd$ do not recurse
               \Comment*{$\tau_c$ and $(\pi, \tau_c)$ belong to $\Delta$ and $\sig F$, resp.}
             } %% Else
       } %% for 
    }
\end{algorithm}
%%%%%%%%%%%%%%%%%

\subsection{The $\LPT[+](S)$ tree}
%%% 
The tentative goal here is to generate all maximal repeats without duplicates in amortized constant time per solusion. The next lemma is based on the framework of the reverse search in enumeration algorithm, and a key to our enumeration. By assumption with $|\Sigma|\ge 2$, the empty string $\eps$ with length zero is the unique shortest maximal repeats of $S$. 

\begin{lemma}\label{lem:maxrep:whatis:parent}
  For any non-empty maximal repeat $v \in \Sigma^+$ in $\MR(S)$, we let the \textit{parent} of $v$, denoted by $\Parent(v)$, to be the longest proper suffix $u$ of $v$, namely, $u = v[1..\ell]$ with some $0\le \ell < |v|$, such that $\rext{u} \not= v$.
  Then, $\Parent(v)$ 
  \begin{enumerate}[(i)]
  \item always exists, and 
  %% \item satisfies that $\rext{u} = u$ and $\lext{u} = u$, and 
  \item is a maximal repeat in $\MR(S)$. 
  \end{enumerate}
\end{lemma}

For generating all elements of $\MR(S)$, it is sufficient to be able to generate the set of its children $\set{u_1, \dots, u_c}$ from a given parent $u$ in $\MR(S)$, 
by reversing the direction of arcs in $\Parent$. This can be done as follows.

%% Note that a factor $v$ of $S$ is left-branching only if its SA-range $i..j$ have width two or more, i.e., $|i..j| \ge 2$. 

\begin{lemma}\label{lem:maxrep:howto:child}
Let $u \in \Sigma^*$ be any maximal repeats in $\MR(S)$ and $v \in \Sigma^+$ be any non-empty string. Then, 
\begin{enumerate*}[(1)]
\item $u = \Parent(v)$ and $v \in \MR(S)$ if and only if 
\item
  \begin{enumerate*}[(i)]
  \item $v = \rext{ua}$ for a character $a\in \Sigma$, and
  \item $v$ is left-branching. 
    %% \item $|i..j| \ge 2$ with
    %% the SA-range $i..j$ of $v$. 
  \end{enumerate*}
\end{enumerate*}
\end{lemma}

Now, we define the tree $\LPT(S)$, called the longest common prefix tree, and its exntension $\LPT[+](S)$ as follows.
From \cref{lem:maxrep:whatis:parent}, we observe that the set $\MR(S)$ of all maximal repeats of $S$ forms a rooted tree, that is, $\LPT(S)$. Specifically, $\LPT(S)$ is the directed tree $\LPT(S) = (\MR(S), \sig E, \eps)$ with
\begin{enumerate*}[(i)]
\item the node set $\MR(S)$, 
\item the root $\eps \in \MR(S)$,   and
\item the set $\sig E := \Parent: \MR(S)\setminus\set{\eps} \to \MR(S)$ of reverse arcs, whose element $(v, u)$ in $\sig E$ represents a reverse arc from a child $v$ to its parent $u  = \Parent(v)$. 
\end{enumerate*}

From \cref{lem:maxrep:howto:child}, we can show that $\sig E$ is precisely the set of all arcs $(u, v)$ for all $u \in \MR(S)$ and a string $v \in \Sigma^+$ with a character $b \in \Sigma$ such that (i) $v = \rext{ub}$ and (ii) $v$ is left-branching with $|\Spos(v)|\ge 2$. 
In addition, we define $\sig F$ to be the set of all arcs $(u, v)$ for all $u \in \MR(S)$ and a string $v \in \Sigma^+$ with a character $b \in \Sigma$ that satisfies the above condition (i) but does not satisfy condition (ii). We call each element of $\sig F$ a \textit{fringe edge} (or a failure edge). Then,

\begin{definition}
the extended longest prefix tree, denoted $\LPT[-](S)$, is the rooted tree
$\LPT[-](S) = (\sig V', \sig E\cup\sig F, \eps)$,
where the edge set is $\sig E\cup\sig F$, and
the node set is 
$\sig V' = \MR(S) \cup \sete{ v \mid (u, v) \in \sig F  }$. 
\end{definition}

\subsection{Traversing $\LPT[+](S)$ tree}
%%% 

\mysubsubsection{Constant-size Representation of factors}
%%% 
We encode any factor, including maximal repeats, of $S$ in a constant-sized representation as follows so that it can be operated in constant time. 
The \textit{rich representation} of a factor $u$ of $S$ is a triple $\tau = (i, j, \ell) \in [n]^3$, where
\begin{itemize}
\item the pair $(i, j)$ with $1\le i\le j\le n$ represents the \textit{SA-range} $i..j\subseteq 1..n$ of $u$ that is the maximal range w.r.t.~set-inclusion consisting of all suffixes of $S$ prefixed by $u$, and  
  
\item the integer $\ell\ge 0$ represents the length of the factor $u$, namely, $\ell = |u|$. 
\end{itemize}

We denote by $\RR$ the set of the rich-representation of all factors of $S$.
We remark that any SA-range $i..j$ without a length component $\ell$ implicitly represents a right-maximal factor of $S$ when we put $\ell$ as the maximum of the lcp-values of two suffixes within $i..j$.


\mysubsubsection{Computing a set of right-branching characters}
%%% 
In \cref{algo:genchildren}, we show a procedure $\GenChildren$ for computing the set of all child ranges of an $\ell$-range, based on precomputed arrays $\LCP, \SA, S$.

%%%%%%%%%%%%%%%%%
{
%% \setlength{\interspacetitleruled}{0pt}%
\setlength{\algotitleheightrule}{0pt}%
\begin{algorithm}[h]
  \caption{
    \textbf{Procedure} $\GenChildren(\pair{i..j, \ell_*}, Children)$.  
  }\label{algo:genchildren}
  %% \KwInput{the triple $W = (i..j, \ell_*)$ for a factor of $S$.}
  %% \textbf{Procedure} $\GenChildren(\pair{i..j, \ell_*}, Children)$:\\
  %% \Begin{
      \If  (\comblk{
        $|i..j| = j - i + 1$.
        %% $\pair{i..j, \ell}$ has no unique occurrences
      })
           {$|i..j| \ge 2$}
           %% {$j - i + 1 \ge 2$}
      {
        $(m, \ell) \gets RMQ_{LCP}(i+1, j)$
        \Comment*{$\ell_m = LCP[m]$}
        \uIf (\comblk{$i..j$ is monotone}) {$\ell_* < \ell_m$}{
          %% $p \gets SA[i]$\;
          $ch \gets S[SA[i]+\ell_*]$\; 
          $Children.\append(\pair{ch, (i..j, \ell_m)})$
          \Comment*{A child $\pair{ch, (i..j, \ell_m)}$}
        }
        \Else  (\CM{$\ell_* = \ell_m$} and $[i,j]$ is diverse) 
        {
          $\GenChildren(\pair{i..m-1, \ell_*}, Children)$\; 
          $\GenChildren(\pair{m..j, \ell_*}, Children)$\;
        }
      }
      \Return $Children$\;
  %% } %% Begin
\end{algorithm}
}
%%%%%%%%%%%%%%%%%

At the top-level, the procedure is invoked with the triple $\pi = (i..j, \ell_*)$ for a factor of $S$ and the pointer to the set $Children = \emptyset$. At every iteration of $\GenChildren$, the following pre-condition must be ensured: $\ell_*$ is the lcp-length of all suffixes in the range $i..j$, namely, $RMQ_{LCP}(i+1, j) = \ell_*$ must hold.

      %% \If{ $Children = \op{undef}$ }{
      %%   We let $Children$ to be the pointer to a newly created set $\emptyset$. 
      %% }



\begin{toappendix}
By definition, we see that
$(i,j,\ell) \in \RR$ if and only if
\begin{enumerate*}[(i)]
\item $k \in i..j \iff u = S[p..p+\ell-1]$ for all $k$, and
\item $\ell = minLCP(i,j)$,
\end{enumerate*}
where $p = SA[k]$ and $minLCP(i,j)$ denotes the minimum LCP-values of an SA-range $i..j$ defined to be $minLCP(i,j) := \max_{i\le k\le j} lcp(S[p..n])$.

\begin{remark}[SA-ranges as a representation of right-maximal factors]
  We remark that any SA-range $i..j$ without a length component $\ell$ implicitly represents a right-maximal factor of $S$ as follows. By letting $\ell$ to be the min-lcp value of the range, that is, $\ell := minLCP(i,j)$, we obtain the triple $(i..j, \ell)$ representing a $u = S[p..p+\ell-1]$ of $S$, where $p = SA[k]$ with an arbitrary $k \in i..j$. Then, it is not hard to see that $u$ is rigit-maximal in $S$.
\end{remark}
\end{toappendix}



\bigskip

%% \subsection{$O(e_{\max})$-worst-case time solution over a constant alphabet}

%% Our solution is based on 

\subsection{Notes} In the end of this article, we show how to replace these structure of $O(n)$ space with index structures of $o(n)$ space for highly-repetitive strings, such as run-length compressed suffix trees or r-index (Gagie, Navarro, and Prezza~\cite{gagie:navarro:prezza2020fully}), by allowing poly-logarithmic slowdown. Since such repetition-aware string indexes have been widely used as the de facto standard method for storing and searching human genome sequences, the proposed method will largely increase the utility of such sequence indexing structures.

\section{Related work}
%%% 
It is well-known that the problem of transforming the suffix array of a string $S$ into its suffix tree $T$ can be solved in $O(n)$ time and space. This is achieved using the suffix array (SA) and the longest common prefix array (LCP)  with an auxiliary stack of size $\idrm{height}(T)$.
This transformation can be performed by simulating either
a bottom-up traversal of the suffix tree, as shown by Kasai \textit{et al.}~\cite{kasai:lee2001lcp:linear} and Crochemore \textit{et al.}~\cite{crochemore2021book125problems:chap:satostree}, or
a top-down traversal as demonstrated by Abouelhoda, Kurtz, and Ohlebusch~\cite{abouelhoda2004replacing}.

Besides this, most closely related work is recent development of $O(n)$-time transformation algorithms for enumeration of \textit{maximal repeats} of a string $S$ using the \textit{Burrows-Wheeler transform} (BWT), 
%%augmented with the \textit{Wavelet tree}.
which simulate a top-down traversal of the tree of the reversed suffix links, called the \textit{Weiner tree}~\cite{beller:berger2012space:efficient:bbo,nishimoto:cpm2021enum}. 
Since the set of maximal repeats corresponds the node set of the CDAWG of the string, they can be expected to be used as a building block to solve the CDAWG construction problem, too. The latest of them, proposed by Nishimoto and Tabei~\cite{nishimoto:cpm2021enum}, runs in $\Theta(n)$-time and $O(r\,\idrm{polylog}(n))$-space based on the r-index~\cite{gagie:navarro:prezza2020fully}.  

Recently, Cleary and Dood~\cite{cleary2023constructing} proposed an algorithm for constructing the CDAWG of a string in the form of a grammar using the SA-intervals of maximal repeats of the string. However, they did not mention how to compute such SA-intervals in $O(e_{\max})$ time and space. 

In summary, to the best of our knowledge, however, it remains an open question whether the CDAWG can be computed from the SA and LCP arrays in output-sensitive manner.
Specifically, it is not known if this can be done using $O(e_{\max})$ or less time and working space --- in addition to the $O(n)$-size read-only inputs --- for repetitive string with right-extension parameter $e_{\max} \le n$.
On the other hand, the proposed algorithm in this paper shows that it is possible to perform translation from the SA and LCP arrays into the CDAWG in output-sensitive time and space by a novel combination of known techniques.  

%%%% 
\section{Notes}
\label{sec:notes}

The relationship between the size of the CDAWG and the parameter $e_{\max}$ was studied by Raffinot~\cite{raffinot2001maximal}, and the use of $e_{\max}$ as a compression parameter was proposed by Belazzougui \textit{et al.}~\cite{belazzougui:nunial:gagie:prezza:raffinot2015composite}.

%%%% 
\section{Conclusion}
\label{sec:concl}
We presented an output-sensitive algorithm for transforming the suffix array of a string with auxiliary structures of $O(n)$ size into the CDAWG of the same string. 
In conclusion, the combination of the simplicity and efficiency would be practical advantages of our algorithm especially when we deal with collections of highly-repetitive strings in the realworld, e.g., human genome sequences and versioned texts of Wikipedia. 


%%%% end of body %%%%%%%%%%%%%%%%%%

% ---- Bibliography ----
\newpage
\bibliographystyle{plain}
\bibliography{ref}
%% \bibliography{bib/ref,ref}
\end{document}

