\section{Appendix}

\subsection{Related Work}

This section provides an overview of text indexing data structures related to this paper. 

\textbf{Text indexing data structures.} In 1973, Weiner \cite{weiner1973linear} proposed the suffix tree as a data structure for efficiently storing all substrings of a given text. He presented an algorithm to construct a suffix tree from a text of length n in $O(n \log n)$ time. A suffix tree has internal nodes corresponding to all right maximal repeats in the text and leaves corresponding to suffixes. Furthermore, he introduced the Weiner tree, a tree structure with the same vertex set as the suffix tree and consisting of the inverse links (called Weiner links) of the suffix links.
%% 
The CDAWG was proposed in 1987 by Blumer, Blumer, Ehrenfeucht, Haussler, and Mc-Connel~\cite{blumer1987complete}. Crochemore and Verin~\cite{crochemore:verin1997compact} gave in 1997 an offline linear-time construction algorithm for CDAWG. Inenaga \textit{et al.}~\cite{inenaga2005online} gave in 2005 an online linear-time construction algorithm for CDAWG.

The \textit{suffix array} is proposed by Manber and Myers~\cite{ManberM93:SA} in 1993, and independently by Gonnet, Baeza-Yates, and Snider~\cite{gonnet1992patarray} in 1992 under the name PAT-array, as a simple and space-efficient alternative to the suffix tree. Manber and Myers~\cite{ManberM93:SA} showed that the suffix array and the \textit{longest common prefix array} (LCP array) can be constructed simultaneously from a text in $O(n \log n)$ time. They presented an algorithm for searching for a substring of length m in $O(m+ \log n)$ time by combining the suffix array with the LCP array. The SA interval representation, a concise representation of substrings in a text, was initially used as an internal structure for pattern matching on suffix arrays.
The \textit{FM-index}, a text indexing structure was proposed by Ferragina and Manzini~\cite{Ferragina05:FM}, which consists of the Burrows–Wheeler transform (BWT) of a text and the Wavelet tree~\cite{grossi2003high}. 

\textbf{Traversal of a suffix tree using array structures.} Maximal repeats have been proposed by several authors as one of the fundamental techniques for enumerating substrings of a text. In 2001, Kasai, Lee, Arimura, Arikawa, and Park~\cite{kasai:lee2001lcp:linear} showed that the bottom-up traversal of a suffix tree can be simulated in $O(n)$ time and space by combining the suffix array, the inverse suffix array, and the longest common prefix array. In 2004, Abouelhoda, Kurtz, and Ohlebusch~\cite{abouelhoda2004replacing} showed that the top-down traversal of a suffix tree can be simulated in $O(n)$ time and space by combining the suffix array and the longest common prefix array. They called a data structure that combines the suffix array with various array structures an enhanced suffix array and demonstrated that many string processing problems that can be solved using suffix trees can also be solved using enhanced suffix arrays.
Beller, Berger, and Ohlebusch~\cite{beller:berger2012space:efficient:bbo} and Beller, Gog, Ohlebusch, and Schnattinger~\cite{bellergogohlebusch2013computing} in 2012 showed that the top-down traversal of the Weiner tree of a text can be simulated in $O(n)$ time and space using the FM-index, an index structure that combines the BWT array and the Wavelet tree data structure. This technique has become one of the fundamental techniques used in many subsequent algorithms for enumerating string features (See the textbook by Ohlebusch~\cite{ohlebusch2013bookbioinfo}).

\textbf{Enumeration of maximal repeats} has been extensively studied in the analysis of texts and genetic sequences (see the textbook by Gusfield~\cite{gusfield1997algorithms}). Gusfield~\cite[Section 7.12.1]{gusfield1997algorithms} gives a slightly complex algorithm for enumerating all maximal repeats using a suffix tree.
Raffinot~\cite{raffinot2001maximal} in 2001 showed first time that the set of all maximal repeats coincides with the set of the longest paths represented by the branching vertices of the CDAWG structure. Based on this characterization, he gave an algorithm for enumerating all maximal repeats in $O(n)$ time and space using the CDAWG.
Narisawa, Inenaga, Bannai, and Takeda (CPM 2007) gave an algorithm for enumerating all maximal repeats in $O(n)$ time and space by combining the suffix array, the inverse suffix array, and the longest common prefix array, based on the algorithm of Kasai \textit{et al.} for simulating the bottom-up traversal of a suffix tree.

Külekci and Vitter~\cite{kulekci2011efficient} in 2012 introduced the idea of combining the BWT array and the Wavelet tree structure and gave a memory-efficient algorithm for enumerating maximal repeats in $O(n \log n)$ time using this idea. Beller, Berger, Ohlebusch~\cite{beller:berger2012space:efficient:bbo}, and Schnattinger extended the algorithm of Beller \textit{et al.}~\cite{bellergogohlebusch2013computing} for simulating the top-down traversal of the Weiner tree and gave an algorithm for enumerating all maximal repeats in $O(n)$time and space using the BWT array and the Wavelet tree structure.
%%% 
In the context of compressed computation, Belazzougui, Cunial, K\"{a}rkk\"{a}inen, and M\"{a}kinen~\cite{belazzougui2020linear} in 2020 gave a compressed data structure (called the \textit{uni-directional BWT-index}) with $n \log\sigma + O(n)$ bits of space for enumerating various string features. They showed that by the depth-first traversal of the Weiner tree using this data structure, maximal repeats can be enumerated in $O(n)$ time with $O(\sigma^2 \log^2 n)$ bits of additional space.

\textbf{Relationship between our algorithms nad the previous work.} The two proposed algorithms in this paper combine existing traversal techniques extracted from the above existing algorithms with new ideas and implementations. The first $O(e_R)$ time enumeration algorithm is based on the idea of reducing the search space using the \textit{Weiner tree property}. Then, it achieves output-sensitive time complexity $O(e_L)$ by combining the \textit{top-down traversal} of the suffix tree using the suffix array and the LCP array by Abouelhoda \textit{et al.}~\cite{abouelhoda2004replacing} in 2004 and the \textit{$O(1)$ time left-branchingity test} by Narisawa \textit{et al.}~\cite{narisawa2007efficient} in 2007. 

On the other hand, the second $O(e_L \log n)$ time enumeration algorithm is an extension of the BBO algorithm based on the \textit{top-down traversal of the Weiner tree} with the BWT array, proposed by Beller \textit{et al.}~\cite{beller:berger2012space:efficient:bbo}, combined with \textit{$O(\log n)$ time maximal extension operation} with the suffix array, the inverse suffix array, and the longest common prefix array to make it output-sensitive. 

%%% EOF
