%% intro2.tex

\section{Introduction (New version)}

\subsection{Backgrounds}
\textit{Full-text search}, which is the task to find all occurrences of a given pattern in a text, is a fundamental problem in information retrieval and sequence analysis. 
We often preprocess the text into a data structure, called a \textit{text index}, to speed-up the following search steps. 
The \textit{suffix tree}~\cite{weiner1973linear} is one of the most basic \textit{graph-based text indexes} for text indexing, which stores all suffixes of a text in linear space, and can be constructed in linear time from a text. By using graph-based text indexes including the suffix tree, we can efficiently solve a wide range of text search and sequence analysis problems.
However, these graph-based text indexes suffers from a number of problems, namely, larger memory usage, and poor cache locality due to their complex, pointer-based structures.

In contrast, the \textit{array-based text indexe}s, such as the \textit{suffix array} (SA)~\cite{manber:myers1993suffixarrays} and \textit{Burrows-Wheeler transform} (BWT) array~\cite{Ferragina05:FM}, emerged for the last decades as space-efficient alternatives of the graph-based indexes although the asymptotic space complexity is the same. 
While they have simple structures in the form of arrays of integers or characters, they still keep sufficient information for searching patterns as in the original suffix tree combined with appropriate auxiliary structures~\cite{manber:myers1993suffixarrays,Ferragina05:FM}. 
Due to their \textit{simplicity} and \textit{efficiency}, these array-based indexes have been becoming popular in  
large-scale text applications like gene sequence analysis.

On the other hand, such array-based indexes lose most of the structural information of the original suffix tree, making it difficult to solve complex sequence analysis problems~\cite{kasai:lee2001lcp:linear,abouelhoda2004replacing}. To overcome this limitation, extensive research has been conducted to find efficient methods for solving string analysis problems using array-based text indexes~\cite{kasai:lee2001lcp:linear,abouelhoda2004replacing,okanohara2009linear,narisawa2007efficient,beller:berger2012space:efficient:bbo,nishimoto:cpm2021enum}. However, none of these algorithms have yet achieved the $O(e)$-time complexity of algorithm using graph-based text indexes for many problems.

\subsection{Research goal}
In this study, we investigate efficient methods for enumerating \textit{maximal repeats} in a given text using array-based text indexes. Maximal repeats (MR)~\cite{raffinot2001maximal} are one of the most fundamental string features of texts and used to characterize many other string features~\cite{gusfield1997algorithms,ohlebusch2013bookbioinfo}. Therefore, the \textit{enumeration of maximal repeats} can be considered one of the most important problems in string analysis.
We assume the following scenario that we  preprocess a given text to construct an index data structure in advance to support effient operation with it, and then we solve various analysis problems multiple times with the index so that the construction time become negligible to the total time of analysis for a long time. 

It is known that all maximal repeats can be compactly stored as a set of nodes in a graph-based index, called the \textit{compact directed acyclic word graph} (CDAWG) in $O(e_R+e_L)$ space, which has $e_R$ forward edges and $e_L$ backward edges (or Weiner links). 
From this, it can be shown that all maximal repeats can be enumerated in $O(e_R)$ or $O(e_L)$ time. 
%The CDAWG represents all maximal repeats in its nodes and connects them with $e_R$ forward edges corresponding to right extensions. 
To the best of our knowledge, this is the fastest known result for enumeration of maximal repeats. 

In contrast, the best time complexity of the currently known array-based enumeration methods for maximal repeats is proportional to the text length $n$. Specifically, they can be classified into \textit{Type-1} algorithms with \textit{bottom-up traversal of the suffix tree} for a text and \textit{Type-2} algorithms with \textit{top-down traversal of the Weiner tree}. However, both methods require $O(n)$ time, and no $O(e)$ time algorithm is known.


%%%%%%%%%%%
%% basic text indexing structures : array-based 
\begin{table}[t]\centering\tabcolsep=.25em 
  \input{tab/table2} %% static indexes
\end{table}
%%%%%%%%%%%

\subsection{Main results}
To address this problem, we propose two array-based algorithms, Algorithm~A and Algorithm~B, 
%one is new and another is a revision of an old one, 
that enumerate all maximal repeats of a text $T$ in $O(e_R)$ time, the same time as the currently fastest graph-based index structure, namely the CDAWG of $T$. 
%%
The proposed algorithms are simple procedures that use only standard array indexes and auxiliary structures in text search and are easy to implement. Since they use an indexing array as a black box, they will be able to get benifit for free from the future advancements of the implementation technology for the array index structures. 

By changing the underlying arrays in a variety of text indexes from uncompressed, entropically compressed, and repetition-based compressed, we have a wide range of Time-Space tradeoff for enumeration of maximal repeats. 
In \cref{table:summary}, we show the summary of our results and existing results. 

\subsection{Techniques}
\subsubsection{Algorithm~A.}
We first propose a new algorithm that enumerates all maximal repeats of a text of length $n$ in $O(e_R\cdot t_\fn{acc}(n))$ time and $O(s_\fn{index}(n))$ space using the suffix and inverse suffix arrays and the longest common prefix (LCP) array for longest common extension (LCE) operation, where $t_\fn{acc}(n)$ and $s_\fn{index}$ are the access time to and the space of all of these arrays. 

As the key, the proposed algorithm performs the traversal of the virtual suffix tree similar to the type-1 algorithms, but performs top-down traversal,  while the existing type-1 algorithms performs bottom-up traversal. To realize this strategy, we adopt the similation method by Abouelhoda et al.~\cite{abouelhoda2004replacing} with the suffix and longest common prefix arrays. 
Then, we prove a new characterization of the region of maximal repeats reside in the suffix tree. 
Due to combination of the characterization and top-down traversal, we can show that unnecessary branches can be pruned using the $O(1)$-time left-branching test with the suffix, inverse suffix, and longest common prefix arrays by modifying the method by \cite{narisawa2007efficient}. 

We remark that to the best of our knowledge, the combination of the top-down traversal of the suffix tree~\cite{abouelhoda2004replacing} and the pruning with left-maximality test~\cite{narisawa2007efficient} is new to accelarate the search for enumeration of maximal repeats, although both techniques have already been invented in 2010s.  

\subsubsection{Algorithm~B.}
The second algorithm is an extension of the type-2 algorithms, which has been widely used for maximal repeats enumeration. Our algorithm traverses the Weiner tree in the top-down manner, where traversal of a Weiner link is similated by application of LF mapping~\cite{Ferragina05:FM}. The test for whether a string is a maximal repeat can be performed in amortized constant time using the range-distinct operation implemented on BWT~\cite{muthukrishnan2002efficient}.

However, since the LF mapping advances only one character at a time, all type-2 algorithms necessarily traverse all  of $O(n)$ Weiner links to find at most $|MR| \le e_R$ maximal repeats. 
We address this issue, we devise an efficient procedure to jump from a maximal repeat to other maximal repeats by skipping all non-branching nodes between them using the internal substring matching (or weighted ancestor queries). In addition, we use a bidirectional index for a text, that is, a pair of text indexes for a text and its reversal. 

By combining this procedure with the standard type-2 algorithms, we propose the algorithm that enumerates all maximal repeats in $O(e)$ time using two copies of the suffix, inverse suffix, and longest common prefix arrays, one for a text and other for the reversed text equipped with the structure for internal substring matching query. 

%\subsection{Summary}



%% EOF
